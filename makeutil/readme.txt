
makefile & /makeutil:

Master makefile for creation of individual makefiles for application
directories.

When in this directory, 'make' or 'make all' will create makefiles or
makefile sets (subsrcxx_o) for application source directories.
[In this context '_o' directories are both sources and targets]

makefiles can be made for individual directories by entering 'make dir-name'

makefiles are dynamic in the sense that the list of elements to make is
generated from the current contents of the source library.  This means that
a makefile cannot be generated properly unless the source library is complete.
Also, the load list for load1 is dynamically derived for source2, etc makefiles.

   [Translation: a makefile for utilsrce_o cannot be made until after 
    utilsrce is compiled from source to .o's...etc.]

	EXCEPTION:  Partitioned directories such as subsrce2_o are controlled 
		    by lists in a corresponding library below makeutil. Each 
		    list corresponds to the contents of one load module.  Care 
		    must be taken to be sure each element of subsrce2_o is 
		    present on one and only one list. (This is of particular 
		    importance for custom subroutines which do not overlay 
		    generic subroutines, but are intended for inclusion 
		    in .sl or .a files.  The lists WILL have to be updated.)
		    Further, the list name is embedded in the makefile, error 
		    file, and load library name for that list.  Naming of list
		    files is important in that the list names control the order
		    in which the load1 elements are listed in source to 
		    executable makefiles.

 Special functions:
  1) 'make genlist': makes the genlist utility used to manipulate lists
                     so that makefiles can be dynamic in the context of current
		      library contents. For more information enter 'genlist -h'
		      or see examples of usage in this makefile.

  2) 'make makedev': makes a prototype makefile for developers - makedev.sam.

  3) 'force_it': there should NEVER be a file or directory in makeutil named
		  'force_it'.  By its absence it is 'out of date' and thus
		  forces the making of makefiles for libraries which DO have
		  counterparts in makeutil such as subsrce2.

 General Comments - This makes use of the fact that most makefiles have 
  common elements. (A makefile for source2 is exactly the same as a makefile
  for sourcecm with the exception of the list of source units processed.,etc.)
  Contained in makeutil are the common fragments of these makefiles.  The
  technique is to make use of the genlist utility to create the dynamic 
  fragments, then to use 'cat' & echo to piece them together with the
  common fragments.  This accompishes one major objective:  removal of 
  manual maintenance (aka typo introduction) for most of the makefile 
  process.  As a side benefit it provides a central location for 
  customization of flag settings etc.


allhdr:
 Common header for .o to .sh or .a master makefile. Copied to 'allmake' by
 makefile, then populated with make -f ... by echo statement in s0o_smake.
 Eventually becomes makefile in subsrcxx_o library.


asubsmake0, asubsmake1:
 Components of the makefile to create a single load1 shared library or archive:
	1. asubsmake0
	2. echo 'OBJA= \'
	3. subsrcr2_o list
	4. echo 'OBJB= \'
	5. subsrcr3_o list
	6. echo 'OBJC= \'
	7. subsrce2_o list
	8. echo 'OBJD= \'
	9. subsrce3_o list
	10. asubsmake1
 Output will reside in subobj_o, if it exists. Note - subobj_o will contain 
 only the makefile.  The .o components are indirectly referenced in their
 respective subsrcxx_o libraries.


csrcmake0, csrcmake1, csrcmake2, csrcmake3, csrcmake4, csrcmakex:
custsrce & presrce makefiles:

 Components used to create a makefile for custom or pre-release source units:
	 1. csrcmake0
	 2. load1 list
	 3. crsrmake1
	 4. path.txt
	 5. csrcmake2
	 6. if custsubs_o exists, 'CUST_EXT_OBJ= \' & custsubs_o list.
	 7. if presubs_o exists, 'PRE_EXT_OBJ= \' & presubs_o list.
	 8. crscmake3
	 9. custsrce list
	 then ...
	10. custsrce list is appended to crscmakex to make a tmpmakex
	11. tmpmakex is executed to append to the output of 1 - 9
	    (using the list and csrcmake4) a rule for each program in custsrce
	12. the finished makefile resides in custsrce.

 The finished makefile allows for static linkage of all units in custsubs_o
 and presubs_o.  By virtue of a separate rule for each program, static linkage
 requirements can be customized on a program by program basis for optimization.

 To preserve optimization, a new makefile will not be made if one exists in 
 the target library.  A new makefile prototype can be generated by removing 
 or renaming the existing makefile in the target library.

 presrce makefile is made in the same way, using the same components.


csubsmake0, csubsmake1, csubsmakex:
psubsmake0 ,psubsmake1, psubsmakex:

 Components used to create a makefile for custom or pre-release subrounines:
	1. xxxmake0
	2. cust or pre subs list
	then the list is appended to xxxmakex, which is executed to append a
	rule for each subroutine, using xxxmake1.
	3. the final makefile will reside in custsubs or presubs, resp.

 The two makefiles will differ only in the target library for compiled units.

 With a separate rule for each unit, it may be possible (on a custom basis)
 to redirect output to a regular _o library for inclusion in a .sh or .a file.
 If this is done it will reduce the number of objects in the static link list,
 and may even remove the necessity of compiling some unmodified programs as
 custom simply to link to custom subroutines.  To accomplish this, simply
 change the object macro in the rules for the individual subroutine.
 
 To preserve optimization, a new makefile will not be made if one exists in 
 the target library.  A new makefile prototype can be generated by removing 
 or renaming the existing makefile in the target library.


endmake:
 Common 'last routine' for makefiles.  Not normally executed during a normal
 make. 


fxs_emake0:
 First component of makefile for fix programs. Remaining components are the
 same as any other source directory (srx_emake1, srx_emake2).  Differs from 
 srx_emake0 only in the target, fix program executables stay in fixes directory.


genlist*, genlist.c:
  Utility to manipulate list putput by ls command into a format suitable for
  embedding in a makefile. Can be made from makeutil by entering 'make genlist'.
  For more information as to capabilities enter 'genlist -h' and/or see
  examples of usage in makeutil/makefile.


makedev.sam, makedev0, makedev1, makedev2:
  Components of a prototye makefile for developers:
	1. makedev0
	2. path.txt
	3. makedev1
	4. load1 list
	5. makedev2

  Flags are set to allow debug, no cleanup is performed (.c, .h, .o remain),
  and supports full range of source -> object makes.  i.e. .bas -> exe,
  .bas -> .o, .bas -> .c, .c -> exe, .c -> .o, and .o -> exe.
  Mostly, this eases the pain of recreating a development makefile if load1
  changes.  Other important variables are the path defintion (location of
  include1, include2, load1, load2) and SPEC_EXT_OBJ for listing subroutines
  under development/debugging for static linkage.


makegen:
  Concatenates s0o_smake with a list from makeutil/subsrcxx to form a temporary 
  makefile in makeutil/subsrcxx.  This makefile then generates makefiles
  for individual load modules, as well as a master makefile for subsrcxx_o.


path.txt:
  Current path to (but not including) load1 and load2.  Updated by global
  makefile.  Its purpose is to provide the linker with a full path so that
  SHRPATH need not be set.


s0o_smake, s1o_smake, s2o_smake:
  Components for creating load module makefiles:
	1. s0o_smake is concatenated with a file list from makeutil/subsrcxx
	2. allhdr is copied to allmake
	3. the temporary makefile from (1) is executed to produce
	   load module makefiles:
	       1. s1o_smake
	       2. object list from subsrcxx/(file)
	       3. s2o_smake 
	       4. the result is make(file)
	4. 'make -f make(file)...' is added to allmake
	5. allmake is copied to subsrcxx_o as makefile
	6. make(file) [s] are copied to subsrcxx_o

   
srx_emake0, srx_emake1, srx_emake2:
  
  The components of a .bas to executable makefile:
	1. srx_emake0
	2. load1 list
	3. src_emake1
	4. path.txt
	5. srx_emake2
	6. sourcexx list
	7. endmake

  The makefiles for all standard source libraries are identical except for
  program lists.  (source2, sourcecd, sourcecm, sourcemc, sourcewa). The
  makefile for fixes differs only in the first component (fsx_emake0) which
  keeps the output in /fixes rather than in ../object2.  If there are special
  linkage requirements, c flag settings, etc desired, these components and the
  corresponding sections of makeutil/makefile are the areas to customize.


ssx_omake0, ssx_omake1:
  Components for creating subroutine source makefiles:
	1. ssx_omake0
	2. echo '$(Oxx)  [OS2, OS3, OR2, OR3 the target]
	3. ssx_omake1
	4. subsrcxx list
	5. endmake

  
subsrce2/, subsrce3/, subsrcr2/, subsrcr3/:
  Each directory contains a set of lists, one list for each element of
  load1 generated from subsrcxx_o.  Each list contains the individual 
  elements of subsrcxx_o which comprise the load module. The naming
  of the lists is significant for two reasons:
	1. the name is embedded in the makefile, load module name and error
	file associated with that list.
	[l1ass2.o -> makel1ass2 -> l1ass2err & load1/libl1ass2]
	2. the contents of load1 must sort into the proper order when preparing
	the contents list of load1 for embedding in source makefiles.
	[l1ass2 == level 1, group a, from ss2; the level number controls sort]
  Auditability - every item in subsrcxx_o should appear on one and only one
  list.  Ommission of an object will cause programs linking to that object to 
  fail.  Inclusion in two or more load modules may cause abiguity and 
  inconsistent results if the subroutine and not all of the load modules 
  are remade.
uco_emake0, uco_emake1:
ucs_omake:
uto_emake0, uto_emake1:
uts_omake:

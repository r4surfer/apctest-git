/*
 exec1: Mon Jan  5 13:02:35 2009
 */

/* include for Oracle Call Interface - we are using 8.0+ format */
#include <oci.h>


/* CALLED SUBPROGRAM */
#include "wvsb.h"

extern sword status;
extern OCISvcCtx *svchp;
extern OCIStmt   *stmthp;
extern OCIError *errhp;
extern ub2 dtype;
extern ub2 dsize;

extern void checkerr( OCIError *errhp, sword status );
extern void cleanup(void);


EXEC1 (STMT1_TS, STMT2_TS, STMT3_TS, STMT4_TS, STMT5_TS, STMT6_TS, STMT7_TS, STMT8_TS, ERR_IS)
struct symbol *STMT1_TS;
struct symbol *STMT2_TS;
struct symbol *STMT3_TS;
struct symbol *STMT4_TS;
struct symbol *STMT5_TS;
struct symbol *STMT6_TS;
struct symbol *STMT7_TS;
struct symbol *STMT8_TS;
struct symbol *ERR_IS;
{

#include "exec1.h"

/* Declare and initialize the local variables */
	int g_ret;
	int g_argcnt = 0;

static struct symbol *allvar[]={
NULL};
static struct ufb *ufbptr[64]={
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
	NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

static int Iflag = 1;
       int G_hold;

extern int Call_args;	/* count of callers args */
int CMS_nargs = Call_args;	/* Local var to keep nargs */

/* local BCD & int pointers to callers parms */
	long *ERR_is;
        int  len1;
        int  len2;
        int  len3;
        int  len4;
        int  len5;
        int  len6;
        int  len7;
        int  len8;
        char string1[2001];

/* pointer to strings */

	text *STMT1_ts;
	text *STMT2_ts; 
	text *STMT3_ts; 
	text *STMT4_ts; 
	text *STMT5_ts; 
	text *STMT6_ts; 
	text *STMT7_ts; 
	text *STMT8_ts; 

/* set the Str COMs */

	g_cidx = 0L;


/* Set pointers to callers parms */
	if ((Call_args >= 9) && (ERR_IS != NULL))
		ERR_is = (long *) *( (long *) ERR_IS + 1);
	if ((Call_args >= 9) && (STMT1_TS != NULL))
	{
		STMT1_ts = (text *) *( (long *) STMT1_TS + 1); 
                memcpy(string1, STMT1_ts, 250);

		STMT2_ts = (text *) *( (long *) STMT2_TS + 1); 
                memcpy(string1+250, STMT2_ts, 250);

		STMT3_ts = (text *) *( (long *) STMT3_TS + 1); 
                memcpy(string1+500, STMT3_ts, 250);

		STMT4_ts = (text *) *( (long *) STMT4_TS + 1); 
                memcpy(string1+750, STMT4_ts, 250);

		STMT5_ts = (text *) *( (long *) STMT5_TS + 1); 
                memcpy(string1+1000, STMT5_ts, 250);

		STMT6_ts = (text *) *( (long *) STMT6_TS + 1); 
                memcpy(string1+1250, STMT6_ts, 250);

		STMT7_ts = (text *) *( (long *) STMT7_TS + 1); 
                memcpy(string1+1500, STMT7_ts, 250);

		STMT8_ts = (text *) *( (long *) STMT8_TS + 1); 
                memcpy(string1+1750, STMT8_ts, 250);

                string1[1999] = '\0';
	}



	wb_init (&Iflag, allvar, NULL);	/* init for sub program */
	G_hold = G_scnt;		/* hold the stack count */
/* 000001        REM *************************************************************~  */ 
/* 000002            *                                                           *~  */ 
/* 000003            *                                                           *~  */ 
/* 000004            *                                                           *~ */ 
/* 000005            *                                                           *~ */ 
/* 000006            *                                                           *~  */ 
/* 000007            *                                                           *~  */ 
/* 000008            *                                                           *~  */ 
/* 000009            *-----------------------------------------------------------*~  */ 
/* 000010            * EXEC1 - Execute a database in Oracle and return results.  *~ */ 
/* 000011            *                                                           *~ */ 
/* 000012            *                                                           *~ */ 
/* 000013            *                                                           *~ */ 
/* 000014            *-----------------------------------------------------------*~ */ 
/* 000015            *                  M O D I F I C A T I O N S                *~ */ 
/* 000016            *---WHEN---+----------------WHAT----------------------+-WHO-*~ */ 
/* 000017            * 01/05/09 ! Original                                 ! CMG *~ */ 
/* 000018            ************************************************************** */ 
/* 000019 */ 
/* 000020            sub  "EXEC1" ( stmt1$(),         :: SQL Stmt Passed In  ::~  */ 
/* 000021                           err% )            :: 0% = OK             :: */ 
/* 000022 */ 
/* 000023            dim stmt1$(8)250                 :: SQL Stmt 1 Passed In::  */ 
/* 000024                 */ 
/* 000025 */ 
/* 000026            err% = 0% */ 
	*(ERR_is) =  0;
/* 000027 */ 
/* 000028 */ 
/* 000029        end */ 

	sb4 parm_status;
	text *col_name;
	ub4 col_name_len;
	OCIDefine *defnp = (OCIDefine *) 0;
	int i;

	/* prepare the statement */
/*        printf("Statement 1 %s\n", string1);  */

	checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (text *) string1,
                                (ub4) strlen((char *) string1),
                                (ub4) OCI_NTV_SYNTAX, (ub4) OCI_COMMIT_ON_SUCCESS));

	/* execute and pre-fetch */
  if (status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
               (CONST OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_COMMIT_ON_SUCCESS))
  {
      /* printf("HERE 1\n");  */
      checkerr(errhp, status);
      cleanup();
      *ERR_is=OCI_ERROR;
       G_scnt = G_hold;	         /* restore stack count */
	  return;
  }

	G_scnt = G_hold;	/* restore stack count */
	return (0);
#ifdef END
#undef END
#endif
END:
	G_scnt = G_hold;	/* restore stack count */
	return  (0);


	/* NO GOSUBS SO NO RETURN TABLE*/
}
/* END OF exec1 */

